{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst debug = require('debug')('record');\n\nconst _require = require('child_process'),\n      spawn = _require.spawn;\n\nconst recorders = require('./recorders');\n\nclass Recording {\n  constructor(options = {}) {\n    const defaults = {\n      sampleRate: 16000,\n      channels: 1,\n      compress: false,\n      threshold: 0.5,\n      thresholdStart: null,\n      thresholdEnd: null,\n      silence: '1.0',\n      recorder: 'sox',\n      endOnSilence: false,\n      audioType: 'wav'\n    };\n    this.options = Object.assign(defaults, options);\n    const recorder = recorders.load(this.options.recorder);\n\n    const _recorder = recorder(this.options),\n          cmd = _recorder.cmd,\n          args = _recorder.args,\n          _recorder$spawnOption = _recorder.spawnOptions,\n          spawnOptions = _recorder$spawnOption === void 0 ? {} : _recorder$spawnOption;\n\n    this.cmd = cmd;\n    this.args = args;\n    this.cmdOptions = Object.assign({\n      encoding: 'binary',\n      stdio: 'pipe'\n    }, spawnOptions);\n    debug(\"Started recording\");\n    debug(this.options);\n    debug(\" \".concat(this.cmd, \" \").concat(this.args.join(' ')));\n    return this.start();\n  }\n\n  start() {\n    const cmd = this.cmd,\n          args = this.args,\n          cmdOptions = this.cmdOptions;\n    const cp = spawn(cmd, args, cmdOptions);\n    const rec = cp.stdout;\n    const err = cp.stderr;\n    this.process = cp; // expose child process\n\n    this._stream = rec; // expose output stream\n\n    cp.on('close', code => {\n      if (code === 0) return;\n      rec.emit('error', \"\".concat(this.cmd, \" has exited with error code \").concat(code, \".\\n\\nEnable debugging with the environment variable DEBUG=record.\"));\n    });\n    err.on('data', chunk => {\n      debug(\"STDERR: \".concat(chunk));\n    });\n    rec.on('data', chunk => {\n      debug(\"Recording \".concat(chunk.length, \" bytes\"));\n    });\n    rec.on('end', () => {\n      debug('Recording ended');\n    });\n    return this;\n  }\n\n  stop() {\n    assert(this.process, 'Recording not yet started');\n    this.process.kill();\n  }\n\n  pause() {\n    assert(this.process, 'Recording not yet started');\n    this.process.kill('SIGSTOP');\n\n    this._stream.pause();\n\n    debug('Paused recording');\n  }\n\n  resume() {\n    assert(this.process, 'Recording not yet started');\n    this.process.kill('SIGCONT');\n\n    this._stream.resume();\n\n    debug('Resumed recording');\n  }\n\n  isPaused() {\n    assert(this.process, 'Recording not yet started');\n    return this._stream.isPaused();\n  }\n\n  stream() {\n    assert(this._stream, 'Recording not yet started');\n    return this._stream;\n  }\n\n}\n\nmodule.exports = {\n  record: (...args) => new Recording(...args)\n};","map":null,"metadata":{},"sourceType":"script"}