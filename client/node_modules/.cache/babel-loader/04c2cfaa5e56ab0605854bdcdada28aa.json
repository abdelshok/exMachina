{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n/* eslint-disable */\n\n/**\n * License (MIT)\n *\n * Copyright Â© 2013 Matt Diamond\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n\n\nvar _inlineWorker = require('inline-worker');\n\nvar _inlineWorker2 = _interopRequireDefault(_inlineWorker);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defaultConfig = {\n  bufferLen: 4096,\n  numChannels: 2,\n  mimeType: 'audio/wav'\n};\n\nvar Microphone = function () {\n  function Microphone(source, config) {\n    var _this = this;\n\n    _classCallCheck(this, Microphone);\n\n    this.config = Object.assign({}, defaultConfig, config);\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels);\n\n    this.node.onaudioprocess = function (e) {\n      if (!_this.recording) return;\n      var buffer = [];\n\n      for (var channel = 0; channel < _this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n\n      _this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination); //this should not be necessary\n\n    var self = {};\n    this.worker = new _inlineWorker2.default(function () {\n      var recLength = 0,\n          recBuffers = [],\n          sampleRate = void 0,\n          numChannels = void 0;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n\n          case 'record':\n            record(e.data.buffer);\n            break;\n\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n\n          case 'getBuffer':\n            getBuffer();\n            break;\n\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        var buffers = [];\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n\n        var interleaved = void 0;\n\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        var dataview = encodeWAV(interleaved);\n        var audioBlob = new Blob([dataview], {\n          type: type\n        });\n        this.postMessage({\n          command: 'exportWAV',\n          data: audioBlob\n        });\n      }\n\n      function getBuffer() {\n        var buffers = [];\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n\n        this.postMessage({\n          command: 'getBuffer',\n          data: buffers\n        });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        var result = new Float32Array(recLength);\n        var offset = 0;\n\n        for (var i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        var length = inputL.length + inputR.length;\n        var result = new Float32Array(length);\n        var index = 0,\n            inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (var i = 0; i < input.length; i++, offset += 2) {\n          var s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (var i = 0; i < string.length; i += 1) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      function encodeWAV(samples) {\n        var buffer = new ArrayBuffer(44 + samples.length * 2);\n        var view = new DataView(buffer);\n        /* RIFF identifier */\n\n        writeString(view, 0, 'RIFF');\n        /* RIFF chunk length */\n\n        view.setUint32(4, 36 + samples.length * 2, true);\n        /* RIFF type */\n\n        writeString(view, 8, 'WAVE');\n        /* format chunk identifier */\n\n        writeString(view, 12, 'fmt ');\n        /* format chunk length */\n\n        view.setUint32(16, 16, true);\n        /* sample format (raw) */\n\n        view.setUint16(20, 1, true);\n        /* channel count */\n\n        view.setUint16(22, numChannels, true);\n        /* sample rate */\n\n        view.setUint32(24, sampleRate, true);\n        /* byte rate (sample rate * block align) */\n\n        view.setUint32(28, sampleRate * 4, true);\n        /* block align (channel count * bytes per sample) */\n\n        view.setUint16(32, numChannels * 2, true);\n        /* bits per sample */\n\n        view.setUint16(34, 16, true);\n        /* data chunk identifier */\n\n        writeString(view, 36, 'data');\n        /* data chunk length */\n\n        view.setUint32(40, samples.length * 2, true);\n        floatTo16BitPCM(view, 44, samples);\n        return view;\n      }\n    }, self);\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = function (e) {\n      var cb = _this.callbacks[e.data.command].pop();\n\n      if (typeof cb === 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  _createClass(Microphone, [{\n    key: 'record',\n    value: function record() {\n      this.recording = true;\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this.recording = false;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.worker.postMessage({\n        command: 'clear'\n      });\n    }\n  }, {\n    key: 'getBuffer',\n    value: function getBuffer(cb) {\n      cb = cb || this.config.callback;\n      if (!cb) throw new Error('Callback not set');\n      this.callbacks.getBuffer.push(cb);\n      this.worker.postMessage({\n        command: 'getBuffer'\n      });\n    }\n  }, {\n    key: 'exportWAV',\n    value: function exportWAV(cb, mimeType) {\n      mimeType = mimeType || this.config.mimeType;\n      cb = cb || this.config.callback;\n      if (!cb) throw new Error('Callback not set');\n      this.callbacks.exportWAV.push(cb);\n      this.worker.postMessage({\n        command: 'exportWAV',\n        type: mimeType\n      });\n    }\n  }]);\n\n  return Microphone;\n}();\n\nMicrophone.forceDownload = function forceDownload(blob, filename) {\n  var a = document.createElement('a');\n  a.style = 'display: none';\n  document.body.appendChild(a);\n  var url = window.URL.createObjectURL(blob);\n  a.href = url;\n  a.download = filename;\n  a.click();\n  window.URL.revokeObjectURL(url);\n  document.body.removeChild(a);\n};\n\nexports.default = Microphone;","map":null,"metadata":{},"sourceType":"script"}