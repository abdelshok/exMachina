{"ast":null,"code":"var _jsxFileName = \"/Users/sergiybokhnyak/Desktop/Work/ChatBotLessons/express-app/client/src/containers/AudioRecordingContainer.js\";\n// External Packages\nimport styled from 'styled-components';\nimport React, { Component } from 'react'; // import axios from 'axios';\n\nimport Button from 'react-bootstrap/Button';\nimport { ReactMic } from 'react-mic'; //import recorder from 'node-record-lpcm16';\n\nimport fs from 'fs';\nimport RecorderJS from 'recorder-js'; // Internal Modules\n// Styled Components\n\nimport AudioRecordingBox from '../styledComponents/AudioRecordingBox';\nimport AudioRecordingButton from '../styledComponents/AudioRecordingButton';\nimport GlobalTheme from '../styledComponents/GlobalTheme';\nvar tracks;\nvar stream;\nconst constraints = {\n  audio: true,\n  video: false\n};\nconst ButtonStyle = {\n  width: '60px',\n  height: '30px',\n  margin: 'auto',\n  display: 'table-cell',\n  verticalAlign: 'middle',\n  padding: 0\n};\nconst AudioOscillationStyle = {\n  width: '200px',\n  height: '80px',\n  marginLeft: '10px'\n};\n/**\n * Get access to the users microphone through the browser.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Using_the_new_API_in_older_browsers\n */\n\nfunction getAudioStream() {\n  // Older browsers might not implement mediaDevices at all, so we set an empty object first\n  if (navigator.mediaDevices === undefined) {\n    navigator.mediaDevices = {};\n  } // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n\n  if (navigator.mediaDevices.getUserMedia === undefined) {\n    navigator.mediaDevices.getUserMedia = function (constraints) {\n      // First get ahold of the legacy getUserMedia, if present\n      var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia; // Some browsers just don't implement it - return a rejected promise with an error\n      // to keep a consistent interface\n\n      if (!getUserMedia) {\n        return Promise.reject(new Error('getUserMedia is not implemented in this browser'));\n      } // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n\n\n      return new Promise(function (resolve, reject) {\n        getUserMedia.call(navigator, constraints, resolve, reject);\n      });\n    };\n  }\n\n  const params = {\n    audio: true,\n    video: false\n  };\n  return navigator.mediaDevices.getUserMedia(params);\n}\n/**\n * Snippets taken from:\n * https://aws.amazon.com/blogs/machine-learning/capturing-voice-input-in-a-browser/\n */\n\n\nconst recordSampleRate = 44100;\n/**\n * Samples the buffer at 16 kHz.\n */\n\nfunction downsampleBuffer(buffer, exportSampleRate) {\n  if (exportSampleRate === recordSampleRate) {\n    return buffer;\n  }\n\n  const sampleRateRatio = recordSampleRate / exportSampleRate;\n  const newLength = Math.round(buffer.length / sampleRateRatio);\n  const result = new Float32Array(newLength);\n  let offsetResult = 0;\n  let offsetBuffer = 0;\n\n  while (offsetResult < result.length) {\n    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    let accum = 0;\n    let count = 0;\n\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n\n  return result;\n}\n\nfunction floatTo16BitPCM(output, offset, input) {\n  for (let i = 0; i < input.length; i++, offset += 2) {\n    const s = Math.max(-1, Math.min(1, input[i]));\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n  }\n}\n\nfunction writeString(view, offset, string) {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n/**\n * Encodes the buffer as a WAV file.\n */\n\n\nfunction encodeWAV(samples) {\n  const buffer = new ArrayBuffer(44 + samples.length * 2);\n  const view = new DataView(buffer);\n  writeString(view, 0, 'RIFF');\n  view.setUint32(4, 32 + samples.length * 2, true);\n  writeString(view, 8, 'WAVE');\n  writeString(view, 12, 'fmt ');\n  view.setUint32(16, 16, true);\n  view.setUint16(20, 1, true);\n  view.setUint16(22, 1, true);\n  view.setUint32(24, recordSampleRate, true);\n  view.setUint32(28, recordSampleRate * 2, true);\n  view.setUint16(32, 2, true);\n  view.setUint16(34, 16, true);\n  writeString(view, 36, 'data');\n  view.setUint32(40, samples.length * 2, true);\n  floatTo16BitPCM(view, 44, samples);\n  return view;\n}\n/**\n * Samples the buffer at 16 kHz.\n * Encodes the buffer as a WAV file.\n * Returns the encoded audio as a Blob.\n */\n\n\nfunction exportBuffer(recBuffer) {\n  const downsampledBuffer = downsampleBuffer(recBuffer, 16000);\n  const encodedWav = encodeWAV(downsampledBuffer); // const audioBlob = new Blob([encodedWav], {\n  //   type: 'application/octet-stream'\n  // });\n  // return audioBlob;\n\n  console.log('Encoded wav', encodedWav);\n  console.log('WAV File');\n  return encodedWav;\n}\n\nclass AudioRecordingContainer extends Component {\n  constructor(props) {\n    super(props);\n\n    this.startRecording = () => {\n      this.setState({\n        record: true\n      }); // recorder.record().stream().pipe(tracks);\n    };\n\n    this.stopRecording = () => {\n      this.setState({\n        record: false\n      });\n      recorder.record().stop();\n    };\n\n    this.getMicrophone = async () => {\n      const audio = await navigator.mediaDevices.getUserMedia(constraints);\n      this.setState({\n        audio\n      });\n    };\n\n    this.stopMicrophone = () => {\n      this.state.audio.getTracks().forEach(track => track.stop());\n      console.log('State of audio', this.state.audio);\n      this.setState({\n        audio: null\n      });\n    };\n\n    this.startRecord = () => {\n      const stream = this.state.stream;\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const recorder = new RecorderJS(audioContext);\n      recorder.init(stream);\n      this.setState({\n        recorder,\n        recording: true\n      }, () => {\n        recorder.start();\n      });\n    };\n\n    this.stopRecord = async () => {\n      const recorder = this.state.recorder;\n\n      const _ref = await recorder.stop(),\n            buffer = _ref.buffer;\n\n      const audio = exportBuffer(buffer[0]); // Do your audio processing here.\n\n      console.log('AUDIO IS', audio);\n      this.setState({\n        recording: false\n      });\n    };\n\n    this.state = {\n      // record: false,\n      // audio: null\n      stream: null,\n      recording: false,\n      recorder: null\n    };\n  } // Event handlers that will take care of triggering audio recording\n  // and stopping it will be set up here \n  // Other event handler will also send the audio recording to an email for now\n  // Will be modified later in order to store it to S3 or generally to \n  // send it to the AI Chatbot's API \n\n\n  async componentDidMount() {\n    let stream;\n\n    try {\n      stream = await getAudioStream();\n    } catch (error) {\n      // If user browser doesn't support audio\n      console.log('Error encountered', error);\n    }\n\n    this.setState({\n      stream\n    });\n  }\n\n  onData(recordedBlob) {\n    console.log('chunk of real-time data is: ', recordedBlob);\n  }\n\n  onStop(recordedBlob) {\n    console.log('recordedBlob is: ', recordedBlob); // console.log('File is', file);\n  }\n\n  render() {\n    const _this$state = this.state,\n          recording = _this$state.recording,\n          stream = _this$state.stream;\n    return React.createElement(AudioRecordingBox, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275\n      },\n      __self: this\n    }, React.createElement(ReactMic, {\n      record: this.state.record,\n      style: AudioOscillationStyle,\n      onStop: this.onStop,\n      onData: this.onData,\n      strokeColor: \"black\",\n      backgroundColor: \"white\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 276\n      },\n      __self: this\n    }), React.createElement(Button, {\n      variant: \"outline-dark\",\n      style: ButtonStyle,\n      onClick: this.startRecord,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 284\n      },\n      __self: this\n    }, \"; > Record\"), React.createElement(Button, {\n      variant: \"outline-dark\",\n      style: ButtonStyle,\n      onClick: this.stopRecord,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 288\n      },\n      __self: this\n    }, \"; > Stop recording\"));\n  }\n\n}\n\nexport default AudioRecordingContainer;","map":{"version":3,"sources":["/Users/sergiybokhnyak/Desktop/Work/ChatBotLessons/express-app/client/src/containers/AudioRecordingContainer.js"],"names":["styled","React","Component","Button","ReactMic","fs","RecorderJS","AudioRecordingBox","AudioRecordingButton","GlobalTheme","tracks","stream","constraints","audio","video","ButtonStyle","width","height","margin","display","verticalAlign","padding","AudioOscillationStyle","marginLeft","getAudioStream","navigator","mediaDevices","undefined","getUserMedia","webkitGetUserMedia","mozGetUserMedia","Promise","reject","Error","resolve","call","params","recordSampleRate","downsampleBuffer","buffer","exportSampleRate","sampleRateRatio","newLength","Math","round","length","result","Float32Array","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","floatTo16BitPCM","output","offset","input","s","max","min","setInt16","writeString","view","string","setUint8","charCodeAt","encodeWAV","samples","ArrayBuffer","DataView","setUint32","setUint16","exportBuffer","recBuffer","downsampledBuffer","encodedWav","console","log","AudioRecordingContainer","constructor","props","startRecording","setState","record","stopRecording","recorder","stop","getMicrophone","stopMicrophone","state","getTracks","forEach","track","startRecord","audioContext","window","AudioContext","webkitAudioContext","init","recording","start","stopRecord","componentDidMount","error","onData","recordedBlob","onStop","render"],"mappings":"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","sourcesContent":["\n// External Packages\nimport styled from 'styled-components';\nimport React, { Component } from 'react';\n// import axios from 'axios';\nimport Button from 'react-bootstrap/Button';\nimport { ReactMic } from 'react-mic';\n//import recorder from 'node-record-lpcm16';\nimport fs from 'fs';\nimport RecorderJS from 'recorder-js';\n// Internal Modules\n// Styled Components\nimport AudioRecordingBox from '../styledComponents/AudioRecordingBox';\nimport AudioRecordingButton from '../styledComponents/AudioRecordingButton';\nimport GlobalTheme from '../styledComponents/GlobalTheme';\n\nvar tracks;\nvar stream;\n\nconst constraints = {\n    audio: true,\n    video: false\n};\n\nconst ButtonStyle = {\n    width: '60px',\n    height: '30px',\n    margin: 'auto',\n    display: 'table-cell',\n    verticalAlign: 'middle',\n    padding: 0,\n}\n\nconst AudioOscillationStyle = {\n    width: '200px',\n    height: '80px',\n    marginLeft: '10px',\n}\n\n\n/**\n * Get access to the users microphone through the browser.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Using_the_new_API_in_older_browsers\n */\nfunction getAudioStream() {\n    // Older browsers might not implement mediaDevices at all, so we set an empty object first\n    if (navigator.mediaDevices === undefined) {\n      navigator.mediaDevices = {};\n    }\n  \n    // Some browsers partially implement mediaDevices. We can't just assign an object\n    // with getUserMedia as it would overwrite existing properties.\n    // Here, we will just add the getUserMedia property if it's missing.\n    if (navigator.mediaDevices.getUserMedia === undefined) {\n      navigator.mediaDevices.getUserMedia = function(constraints) {\n        // First get ahold of the legacy getUserMedia, if present\n        var getUserMedia =\n          navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n  \n        // Some browsers just don't implement it - return a rejected promise with an error\n        // to keep a consistent interface\n        if (!getUserMedia) {\n          return Promise.reject(\n            new Error('getUserMedia is not implemented in this browser')\n          );\n        }\n  \n        // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n        return new Promise(function(resolve, reject) {\n          getUserMedia.call(navigator, constraints, resolve, reject);\n        });\n      };\n    }\n  \n    const params = { audio: true, video: false };\n  \n    return navigator.mediaDevices.getUserMedia(params);\n  }\n  \n  /**\n   * Snippets taken from:\n   * https://aws.amazon.com/blogs/machine-learning/capturing-voice-input-in-a-browser/\n   */\n  \n  const recordSampleRate = 44100;\n  \n  /**\n   * Samples the buffer at 16 kHz.\n   */\n  function downsampleBuffer(buffer, exportSampleRate) {\n    if (exportSampleRate === recordSampleRate) {\n      return buffer;\n    }\n  \n    const sampleRateRatio = recordSampleRate / exportSampleRate;\n    const newLength = Math.round(buffer.length / sampleRateRatio);\n    const result = new Float32Array(newLength);\n  \n    let offsetResult = 0;\n    let offsetBuffer = 0;\n  \n    while (offsetResult < result.length) {\n      const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n      let accum = 0;\n      let count = 0;\n  \n      for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n        accum += buffer[i];\n        count++;\n      }\n  \n      result[offsetResult] = accum / count;\n      offsetResult++;\n      offsetBuffer = nextOffsetBuffer;\n    }\n  \n    return result;\n  }\n  \n  function floatTo16BitPCM(output, offset, input) {\n    for (let i = 0; i < input.length; i++, offset += 2) {\n      const s = Math.max(-1, Math.min(1, input[i]));\n      output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n  }\n  \n  function writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  }\n  \n  /**\n   * Encodes the buffer as a WAV file.\n   */\n  function encodeWAV(samples) {\n    const buffer = new ArrayBuffer(44 + samples.length * 2);\n    const view = new DataView(buffer);\n  \n    writeString(view, 0, 'RIFF');\n    view.setUint32(4, 32 + samples.length * 2, true);\n    writeString(view, 8, 'WAVE');\n    writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 1, true);\n    view.setUint32(24, recordSampleRate, true);\n    view.setUint32(28, recordSampleRate * 2, true);\n    view.setUint16(32, 2, true);\n    view.setUint16(34, 16, true);\n    writeString(view, 36, 'data');\n    view.setUint32(40, samples.length * 2, true);\n    floatTo16BitPCM(view, 44, samples);\n  \n    return view;\n  }\n  \n  /**\n   * Samples the buffer at 16 kHz.\n   * Encodes the buffer as a WAV file.\n   * Returns the encoded audio as a Blob.\n   */\n  function exportBuffer(recBuffer) {\n    const downsampledBuffer = downsampleBuffer(recBuffer, 16000);\n    const encodedWav = encodeWAV(downsampledBuffer);\n    // const audioBlob = new Blob([encodedWav], {\n    //   type: 'application/octet-stream'\n    // });\n  \n    // return audioBlob;\n    console.log('Encoded wav', encodedWav);\n    console.log('WAV File')\n    return encodedWav;\n  }\n  \n\nclass AudioRecordingContainer extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // record: false,\n            // audio: null\n            stream: null,\n            recording: false,\n            recorder: null\n        }\n    }\n\n    // Event handlers that will take care of triggering audio recording\n    // and stopping it will be set up here \n\n    // Other event handler will also send the audio recording to an email for now\n    // Will be modified later in order to store it to S3 or generally to \n    // send it to the AI Chatbot's API \n\n    async componentDidMount() {\n        let stream;\n\n        try {\n            stream = await getAudioStream();\n        } catch (error) {\n            // If user browser doesn't support audio\n            console.log('Error encountered', error);\n        }\n\n        this.setState({ stream });\n    }\n\n    startRecording = () => {\n        this.setState({\n            record: true\n        });\n        // recorder.record().stream().pipe(tracks);\n    }\n\n    stopRecording = () => {\n        this.setState({\n            record: false\n        });\n        recorder.record().stop();\n    }\n\n    onData(recordedBlob) {\n        console.log('chunk of real-time data is: ', recordedBlob);\n    }\n     \n    onStop(recordedBlob) {\n        console.log('recordedBlob is: ', recordedBlob);\n        // console.log('File is', file);\n    }\n     \n    getMicrophone = async () => {\n        const audio = await navigator.mediaDevices.getUserMedia(constraints); \n        this.setState({ audio });\n    }\n     \n    stopMicrophone = () => {\n        this.state.audio.getTracks().forEach(track => track.stop());\n        console.log('State of audio', this.state.audio);\n        this.setState({ audio: null});\n    }\n\n    startRecord = () => {\n        const { stream } = this.state;\n        const audioContext = new (window.AudioContext ||window.webkitAudioContext)();\n        const recorder = new RecorderJS(audioContext);\n        recorder.init(stream);\n        this.setState(\n          {\n            recorder,\n            recording: true\n          },\n          () => {\n            recorder.start();\n          }\n        );\n    }\n\n    stopRecord = async () => {\n        const { recorder } = this.state;\n        const { buffer } = await recorder.stop()\n        const audio = exportBuffer(buffer[0]);\n        // Do your audio processing here.\n        console.log('AUDIO IS', audio);\n        this.setState({\n          recording: false\n        });\n    }\n\n    render() {\n        const { recording, stream } = this.state;\n\n        return (\n            <AudioRecordingBox >\n                <ReactMic\n                record={this.state.record}\n                style={AudioOscillationStyle}\n                onStop={this.onStop}\n                onData={this.onData}\n                strokeColor=\"black\"\n                backgroundColor=\"white\" \n                />\n                <Button variant=\"outline-dark\" style={ButtonStyle} onClick={this.startRecord}>;\n                > \n                Record\n                </Button>\n                <Button variant=\"outline-dark\" style={ButtonStyle} onClick={this.stopRecord}>;\n                > \n                Stop recording\n                </Button>\n            </AudioRecordingBox>\n        )\n    }\n}\n\nexport default AudioRecordingContainer;"]},"metadata":{},"sourceType":"module"}